#!/bin/sh

# Configuration
use_keyring=1
use_https=1

# Interpret the 'keyfile' argument
if [ -z "$CRYPTTAB_KEY" ]; then
  CRYPTTAB_KEY=$1
fi

sedRegex="^\(.\+\):\(https:\/\/.\+\)$"

openssl_passphrase="$(echo "$CRYPTTAB_KEY" | sed -n -e "s/$sedRegex/\1/p")"
url="$(echo "$CRYPTTAB_KEY" | sed -n -e "s/$sedRegex/\2/p")"

keyctl_id="crypttab:$CRYPTTAB_KEY"


# If this isn't the first attempt,
# or there were problems with getting either a passphrase or a url
# switch off any attempt to fetch the key remotely or by the keyring

if [ "$CRYPTTAB_TRIED" -gt 0 ] || [ -z "$url" ] || [ -z "$openssl_passphrase" ]; then
  use_keyring=0
  use_https=0
fi

#
# Plymouth helper functions
#
use_plymouth=0
if [ -x /bin/plymouth ] && plymouth --ping; then
    use_plymouth=1
fi

message ()
{
  echo "$1" | while read LINE; do
    if [ $use_plymouth -eq 1 ]; then
      plymouth message --text="$LINE"
    else
      echo "$LINE" >&2
    fi
  done
}

askpass ()
{
  if [ $use_plymouth -eq 1 ]; then
    passphrase="$(plymouth ask-for-password --prompt "$1")"
    printf '%s' "$passphrase"
  else
    /lib/cryptsetup/askpass "$1"
  fi
}

#
# Kernel keyring functions
#
keyctl_try_fetch ()
{

  if [ $use_keyring -eq 0 ]; then
    return 0
  fi

  kSerial="$(keyctl search @u user "$keyctl_id" 2>&1)"
  exitCode=$?

  if [ $exitCode -eq 0 ]; then
    message "Retrieved key for $CRYPTTAB_NAME from keyring"
    keyctl pipe "$kSerial"
    exit
  fi

  # Exit code of 1 indicates a failed search
  if [ $exitCode -ne 1 ]; then
    message "Error retrieving from keyring: $kSerial"
  fi 

}

keyctl_store ()
{
  if [ $use_keyring -eq 0 ]; then
    return 0
  fi

  kSerial="$(printf '%s\n' "$decrypted_keyfile" | keyctl padd user "$keyctl_id" @u 2>&1)"
  exitCode=$?

  if [ $exitCode -ne 0 ]; then
    message "Error saving to keyring: $kSerial"
  fi

  if [ $exitCode -eq 0 ]; then
    keyctl timeout "$kSerial" 60

    if [ $? -ne 0 ]; then
      keyctl unlink "$kSerial"
    fi

    return
  fi


}

#
# Finally the function to fetch the keyfile by HTTPS 
#

https_try_fetch ()
{
  if [ $use_https -eq 0 ]; then
    return 0
  fi

  message "Fetching remote keyfile for $CRYPTTAB_NAME..."

  # Specify the full path, otherwise you get busybox's wget
  encrypted_keyfile=$(/usr/bin/wget --secure-protocol=PFS -q -O - "$url")

  if [ $? -eq 0 ]; then
    decrypted_keyfile=$(echo "$encrypted_keyfile" | openssl enc -base64 -aes-256-cbc -md sha256 -d -salt -k "$openssl_passphrase")
    if [ $? -eq 0 ]; then
      keyctl_store
      printf '%s\n' "$decrypted_keyfile"
      exit
    fi
  fi
}


keyctl_try_fetch
https_try_fetch

askpass "Getting passphrase remotely failed for $CRYPTTAB_NAME. Enter passphrase: "
